<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>bitcoin-atom-master_src_secp256k1_src_field_10x26_impl.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>bitcoin-atom-master_src_secp256k1_src_field_10x26_impl.h</CENTER></H3><HR>
<PRE>
/**********************************************************************
 * Copyright (c) 2013, 2014 Pieter Wuille                             *
 * Distributed under the MIT software license, see the accompanying   *
 * file COPYING or http://www.opensource.org/licenses/mit-license.php.*
 **********************************************************************/

#ifndef SECP256K1_FIELD_REPR_IMPL_H
#define SECP256K1_FIELD_REPR_IMPL_H

#include &quot;util.h&quot;
#include &quot;num.h&quot;
#include &quot;field.h&quot;

#ifdef VERIFY
static void secp256k1_fe_verify(const secp256k1_fe *a) {
    const uint32_t *d = a-&gt;n;
    int m = a-&gt;normalized ? 1 : 2 * a-&gt;magnitude, r = 1;
    r &amp;= (d[0] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[1] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[2] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[3] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[4] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[5] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[6] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[7] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[8] &lt;= 0x3FFFFFFUL * m);
    r &amp;= (d[9] &lt;= 0x03FFFFFUL * m);
    r &amp;= (a-&gt;magnitude &gt;= 0);
    r &amp;= (a-&gt;magnitude &lt;= 32);
    if (a-&gt;normalized) {
        r &amp;= (a-&gt;magnitude &lt;= 1);
        if (r &amp;&amp; (d[9] == 0x03FFFFFUL)) {
            uint32_t mid = d[8] &amp; d[7] &amp; d[6] &amp; d[5] &amp; d[4] &amp; d[3] &amp; d[2];
            if (mid == 0x3FFFFFFUL) {
                r &amp;= ((d[1] + 0x40UL + ((d[0] + 0x3D1UL) &gt;&gt; 26)) &lt;= 0x3FFFFFFUL);
            }
        }
    }
    VERIFY_CHECK(r == 1);
}
#endif

static void secp256k1_fe_normalize(secp256k1_fe *r) {
    uint32_t t0 = r-&gt;n[0], t1 = r-&gt;n[1], t2 = r-&gt;n[2], t3 = r-&gt;n[3], t4 = r-&gt;n[4],
             t5 = r-&gt;n[5], t6 = r-&gt;n[6], t7 = r-&gt;n[7], t8 = r-&gt;n[8], t9 = r-&gt;n[9];

    /* Reduce t9 at the start so there will be at most a single carry from the first pass */
    uint32_t m;
    uint32_t x = t9 &gt;&gt; 22; t9 &amp;= 0x03FFFFFUL;

    /* The first pass ensures the magnitude is 1, ... */
    t0 += x * 0x3D1UL; t1 += (x &lt;&lt; 6);
    t1 += (t0 &gt;&gt; 26); t0 &amp;= 0x3FFFFFFUL;
    t2 += (t1 &gt;&gt; 26); t1 &amp;= 0x3FFFFFFUL;
    t3 += (t2 &gt;&gt; 26); t2 &amp;= 0x3FFFFFFUL; m = t2;
    t4 += (t3 &gt;&gt; 26); t3 &amp;= 0x3FFFFFFUL; m &amp;= t3;
    t5 += (t4 &gt;&gt; 26); t4 &amp;= 0x3FFFFFFUL; m &amp;= t4;
    t6 += (t5 &gt;&gt; 26); t5 &amp;= 0x3FFFFFFUL; m &amp;= t5;
    t7 += (t6 &gt;&gt; 26); t6 &amp;= 0x3FFFFFFUL; m &amp;= t6;
    t8 += (t7 &gt;&gt; 26); t7 &amp;= 0x3FFFFFFUL; m &amp;= t7;
    t9 += (t8 &gt;&gt; 26); t8 &amp;= 0x3FFFFFFUL; m &amp;= t8;

    /* ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) */
    VERIFY_CHECK(t9 &gt;&gt; 23 == 0);

    /* At most a single final reduction is needed; check if the value is &gt;= the field characteristic */
    x = (t9 &gt;&gt; 22) | ((t9 == 0x03FFFFFUL) &amp; (m == 0x3FFFFFFUL)
        &amp; ((t1 + 0x40UL + ((t0 + 0x3D1UL) &gt;&gt; 26)) &gt; 0x3FFFFFFUL));

    /* Apply the final reduction (for constant-time behaviour, we do it always) */
    t0 += x * 0x3D1UL; t1 += (x &lt;&lt; 6);
    t1 += (t0 &gt;&gt; 26); t0 &amp;= 0x3FFFFFFUL;
    t2 += (t1 &gt;&gt; 26); t1 &amp;= 0x3FFFFFFUL;
    t3 += (t2 &gt;&gt; 26); t2 &amp;= 0x3FFFFFFUL;
    t4 += (t3 &gt;&gt; 26); t3 &amp;= 0x3FFFFFFUL;
    t5 += (t4 &gt;&gt; 26); t4 &amp;= 0x3FFFFFFUL;
    t6 += (t5 &gt;&gt; 26); t5 &amp;= 0x3FFFFFFUL;
    t7 += (t6 &gt;&gt; 26); t6 &amp;= 0x3FFFFFFUL;
    t8 += (t7 &gt;&gt; 26); t7 &amp;= 0x3FFFFFFUL;
    t9 += (t8 &gt;&gt; 26); t8 &amp;= 0x3FFFFFFUL;

    /* If t9 didn't carry to bit 22 already, then it should have after any final reduction */
    VERIFY_CHECK(t9 &gt;&gt; 22 == x);

    /* Mask off the possible multiple of 2^256 from the final reduction */
    t9 &amp;= 0x03FFFFFUL;

    r-&gt;n[0] = t0; r-&gt;n[1] = t1; r-&gt;n[2] = t2; r-&gt;n[3] = t3; r-&gt;n[4] = t4;
    r-&gt;n[5] = t5; r-&gt;n[6] = t6; r-&gt;n[7] = t7; r-&gt;n[8] = t8; r-&gt;n[9] = t9;

#ifdef VERIFY
    r-&gt;magnitude = 1;
    r-&gt;normalized = 1;
    secp256k1_fe_verify(r);
#endif
}

static void secp256k1_fe_normalize_weak(secp256k1_fe *r) {
    uint32_t t0 = r-&gt;n[0], t1 = r-&gt;n[1], t2 = r-&gt;n[2], t3 = r-&gt;n[3], t4 = r-&gt;n[4],
             t5 = r-&gt;n[5], t6 = r-&gt;n[6], t7 = r-&gt;n[7], t8 = r-&gt;n[8], t9 = r-&gt;n[9];

    /* Reduce t9 at the start so there will be at most a single carry from the first pass */
    uint32_t x = t9 &gt;&gt; 22; t9 &amp;= 0x03FFFFFUL;

    /* The first pass ensures the magnitude is 1, ... */
    t0 += x * 0x3D1UL; t1 += (x &lt;&lt; 6);
    t1 += (t0 &gt;&gt; 26); t0 &amp;= 0x3FFFFFFUL;
    t2 += (t1 &gt;&gt; 26); t1 &amp;= 0x3FFFFFFUL;
    t3 += (t2 &gt;&gt; 26); t2 &amp;= 0x3FFFFFFUL;
    t4 += (t3 &gt;&gt; 26); t3 &amp;= 0x3FFFFFFUL;
    t5 += (t4 &gt;&gt; 26); t4 &amp;= 0x3FFFFFFUL;
    t6 += (t5 &gt;&gt; 26); t5 &amp;= 0x3FFFFFFUL;
    t7 += (t6 &gt;&gt; 26); t6 &amp;= 0x3FFFFFFUL;
    t8 += (t7 &gt;&gt; 26); t7 &amp;= 0x3FFFFFFUL;
    t9 += (t8 &gt;&gt; 26); t8 &amp;= 0x3FFFFFFUL;

    /* ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) */
    VERIFY_CHECK(t9 &gt;&gt; 23 == 0);

    r-&gt;n[0] = t0; r-&gt;n[1] = t1; r-&gt;n[2] = t2; r-&gt;n[3] = t3; r-&gt;n[4] = t4;
    r-&gt;n[5] = t5; r-&gt;n[6] = t6; r-&gt;n[7] = t7; r-&gt;n[8] = t8; r-&gt;n[9] = t9;

#ifdef VERIFY
    r-&gt;magnitude = 1;
    secp256k1_fe_verify(r);
#endif
}

static void secp256k1_fe_normalize_var(secp256k1_fe *r) {
    uint32_t t0 = r-&gt;n[0], t1 = r-&gt;n[1], t2 = r-&gt;n[2], t3 = r-&gt;n[3], t4 = r-&gt;n[4],
             t5 = r-&gt;n[5], t6 = r-&gt;n[6], t7 = r-&gt;n[7], t8 = r-&gt;n[8], t9 = r-&gt;n[9];

    /* Reduce t9 at the start so there will be at most a single carry from the first pass */
    uint32_t m;
    uint32_t x = t9 &gt;&gt; 22; t9 &amp;= 0x03FFFFFUL;

    /* The first pass ensures the magnitude is 1, ... */
    t0 += x * 0x3D1UL; t1 += (x &lt;&lt; 6);
    t1 += (t0 &gt;&gt; 26); t0 &amp;= 0x3FFFFFFUL;
    t2 += (t1 &gt;&gt; 26); t1 &amp;= 0x3FFFFFFUL;
    t3 += (t2 &gt;&gt; 26); t2 &amp;= 0x3FFFFFFUL; m = t2;
    t4 += (t3 &gt;&gt; 26); t3 &amp;= 0x3FFFFFFUL; m &amp;= t3;
    t5 += (t4 &gt;&gt; 26); t4 &amp;= 0x3FFFFFFUL; m &amp;= t4;
    t6 += (t5 &gt;&gt; 26); t5 &amp;= 0x3FFFFFFUL; m &amp;= t5;
    t7 += (t6 &gt;&gt; 26); t6 &amp;= 0x3FFFFFFUL; m &amp;= t6;
    t8 += (t7 &gt;&gt; 26); t7 &amp;= 0x3FFFFFFUL; m &amp;= t7;
    t9 += (t8 &gt;&gt; 26); t8 &amp;= 0x3FFFFFFUL; m &amp;= t8;

    /* ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) */
    VERIFY_CHECK(t9 &gt;&gt; 23 == 0);

    /* At most a single final reduction is needed; check if the value is &gt;= the field characteristic */
    x = (t9 &gt;&gt; 22) | ((t9 == 0x03FFFFFUL) &amp; (m == 0x3FFFFFFUL)
        &amp; ((t1 + 0x40UL + ((t0 + 0x3D1UL) &gt;&gt; 26)) &gt; 0x3FFFFFFUL));

    if (x) {
        t0 += 0x3D1UL; t1 += (x &lt;&lt; 6);
        t1 += (t0 &gt;&gt; 26); t0 &amp;= 0x3FFFFFFUL;
        t2 += (t1 &gt;&gt; 26); t1 &amp;= 0x3FFFFFFUL;
        t3 += (t2 &gt;&gt; 26); t2 &amp;= 0x3FFFFFFUL;
        t4 += (t3 &gt;&gt; 26); t3 &amp;= 0x3FFFFFFUL;
        t5 += (t4 &gt;&gt; 26); t4 &amp;= 0x3FFFFFFUL;
        t6 += (t5 &gt;&gt; 26); t5 &amp;= 0x3FFFFFFUL;
        t7 += (t6 &gt;&gt; 26); t6 &amp;= 0x3FFFFFFUL;
        t8 += (t7 &gt;&gt; 26); t7 &amp;= 0x3FFFFFFUL;
        t9 += (t8 &gt;&gt; 26); t8 &amp;= 0x3FFFFFFUL;

        /* If t9 didn't carry to bit 22 already, then it should have after any final reduction */
        VERIFY_CHECK(t9 &gt;&gt; 22 == x);

        /* Mask off the possible multiple of 2^256 from the final reduction */
        t9 &amp;= 0x03FFFFFUL;
    }

    r-&gt;n[0] = t0; r-&gt;n[1] = t1; r-&gt;n[2] = t2; r-&gt;n[3] = t3; r-&gt;n[4] = t4;
    r-&gt;n[5] = t5; r-&gt;n[6] = t6; r-&gt;n[7] = t7; r-&gt;n[8] = t8; r-&gt;n[9] = t9;

#ifdef VERIFY
    r-&gt;magnitude = 1;
    r-&gt;normalized = 1;
    secp256k1_fe_verify(r);
#endif
}

static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {
    uint32_t t0 = r-&gt;n[0], t1 = r-&gt;n[1], t2 = r-&gt;n[2], t3 = r-&gt;n[3], t4 = r-&gt;n[4],
             t5 = r-&gt;n[5], t6 = r-&gt;n[6], t7 = r-&gt;n[7], t8 = r-&gt;n[8], t9 = r-&gt;n[9];

    /* z0 tracks a possible raw value of 0, z1 tracks a possible raw value of P */
    uint32_t z0, z1;

    /* Reduce t9 at the start so there will be at most a single carry from the first pass */
    uint32_t x = t9 &gt;&gt; 22; t9 &amp;= 0x03FFFFFUL;

    /* The first pass ensures the magnitude is 1, ... */
    t0 += x * 0x3D1UL; t1 += (x &lt;&lt; 6);
    t1 += (t0 &gt;&gt; 26); t0 &amp;= 0x3FFFFFFUL; z0  = t0; z1  = t0 ^ 0x3D0UL;
    t2 += (t1 &gt;&gt; 26); t1 &amp;= 0x3FFFFFFUL; z0 |= t1; z1 &amp;= t1 ^ 0x40UL;
    t3 += (t2 &gt;&gt; 26); t2 &amp;= 0x3FFFFFFUL; z0 |= t2; z1 &amp;= t2;
    t4 += (t3 &gt;&gt; 26); t3 &amp;= 0x3FFFFFFUL; z0 |= t3; z1 &amp;= t3;
    t5 += (t4 &gt;&gt; 26); t4 &amp;= 0x3FFFFFFUL; z0 |= t4; z1 &amp;= t4;
    t6 += (t5 &gt;&gt; 26); t5 &amp;= 0x3FFFFFFUL; z0 |= t5; z1 &amp;= t5;
    t7 += (t6 &gt;&gt; 26); t6 &amp;= 0x3FFFFFFUL; z0 |= t6; z1 &amp;= t6;
    t8 += (t7 &gt;&gt; 26); t7 &amp;= 0x3FFFFFFUL; z0 |= t7; z1 &amp;= t7;
    t9 += (t8 &gt;&gt; 26); t8 &amp;= 0x3FFFFFFUL; z0 |= t8; z1 &amp;= t8;
                                         z0 |= t9; z1 &amp;= t9 ^ 0x3C00000UL;

    /* ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) */
    VERIFY_CHECK(t9 &gt;&gt; 23 == 0);

    return (z0 == 0) | (z1 == 0x3FFFFFFUL);
}

static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r) {
    uint32_t t0, t1, t2, t3, t4, t5, t6, t7, t8, t9;
    uint32_t z0, z1;
    uint32_t x;

    t0 = r-&gt;n[0];
    t9 = r-&gt;n[9];

    /* Reduce t9 at the start so there will be at most a single carry from the first pass */
    x = t9 &gt;&gt; 22;

    /* The first pass ensures the magnitude is 1, ... */
    t0 += x * 0x3D1UL;

    /* z0 tracks a possible raw value of 0, z1 tracks a possible raw value of P */
    z0 = t0 &amp; 0x3FFFFFFUL;
    z1 = z0 ^ 0x3D0UL;

    /* Fast return path should catch the majority of cases */
    if ((z0 != 0UL) &amp; (z1 != 0x3FFFFFFUL)) {
        return 0;
    }

    t1 = r-&gt;n[1];
    t2 = r-&gt;n[2];
    t3 = r-&gt;n[3];
    t4 = r-&gt;n[4];
    t5 = r-&gt;n[5];
    t6 = r-&gt;n[6];
    t7 = r-&gt;n[7];
    t8 = r-&gt;n[8];

    t9 &amp;= 0x03FFFFFUL;
    t1 += (x &lt;&lt; 6);

    t1 += (t0 &gt;&gt; 26);
    t2 += (t1 &gt;&gt; 26); t1 &amp;= 0x3FFFFFFUL; z0 |= t1; z1 &amp;= t1 ^ 0x40UL;
    t3 += (t2 &gt;&gt; 26); t2 &amp;= 0x3FFFFFFUL; z0 |= t2; z1 &amp;= t2;
    t4 += (t3 &gt;&gt; 26); t3 &amp;= 0x3FFFFFFUL; z0 |= t3; z1 &amp;= t3;
    t5 += (t4 &gt;&gt; 26); t4 &amp;= 0x3FFFFFFUL; z0 |= t4; z1 &amp;= t4;
    t6 += (t5 &gt;&gt; 26); t5 &amp;= 0x3FFFFFFUL; z0 |= t5; z1 &amp;= t5;
    t7 += (t6 &gt;&gt; 26); t6 &amp;= 0x3FFFFFFUL; z0 |= t6; z1 &amp;= t6;
    t8 += (t7 &gt;&gt; 26); t7 &amp;= 0x3FFFFFFUL; z0 |= t7; z1 &amp;= t7;
    t9 += (t8 &gt;&gt; 26); t8 &amp;= 0x3FFFFFFUL; z0 |= t8; z1 &amp;= t8;
                                         z0 |= t9; z1 &amp;= t9 ^ 0x3C00000UL;

    /* ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) */
    VERIFY_CHECK(t9 &gt;&gt; 23 == 0);

    return (z0 == 0) | (z1 == 0x3FFFFFFUL);
}

SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe *r, int a) {
    r-&gt;n[0] = a;
    r-&gt;n[1] = r-&gt;n[2] = r-&gt;n[3] = r-&gt;n[4] = r-&gt;n[5] = r-&gt;n[6] = r-&gt;n[7] = r-&gt;n[8] = r-&gt;n[9] = 0;
#ifdef VERIFY
    r-&gt;magnitude = 1;
    r-&gt;normalized = 1;
    secp256k1_fe_verify(r);
#endif
}

SECP256K1_INLINE static int secp256k1_fe_is_zero(const secp256k1_fe *a) {
    const uint32_t *t = a-&gt;n;
#ifdef VERIFY
    VERIFY_CHECK(a-&gt;normalized);
    secp256k1_fe_verify(a);
#endif
    return (t[0] | t[1] | t[2] | t[3] | t[4] | t[5] | t[6] | t[7] | t[8] | t[9]) == 0;
}

SECP256K1_INLINE static int secp256k1_fe_is_odd(const secp256k1_fe *a) {
#ifdef VERIFY
    VERIFY_CHECK(a-&gt;normalized);
    secp256k1_fe_verify(a);
#endif
    return a-&gt;n[0] &amp; 1;
}

SECP256K1_INLINE static void secp256k1_fe_clear(secp256k1_fe *a) {
    int i;
#ifdef VERIFY
    a-&gt;magnitude = 0;
    a-&gt;normalized = 1;
#endif
    for (i=0; i&lt;10; i++) {
        a-&gt;n[i] = 0;
    }
}

static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {
    int i;
#ifdef VERIFY
    VERIFY_CHECK(a-&gt;normalized);
    VERIFY_CHECK(b-&gt;normalized);
    secp256k1_fe_verify(a);
    secp256k1_fe_verify(b);
#endif
    for (i = 9; i &gt;= 0; i--) {
        if (a-&gt;n[i] &gt; b-&gt;n[i]) {
            return 1;
        }
        if (a-&gt;n[i] &lt; b-&gt;n[i]) {
            return -1;
        }
    }
    return 0;
}

static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {
    r-&gt;n[0] = (uint32_t)a[31] | ((uint32_t)a[30] &lt;&lt; 8) | ((uint32_t)a[29] &lt;&lt; 16) | ((uint32_t)(a[28] &amp; 0x3) &lt;&lt; 24);
    r-&gt;n[1] = (uint32_t)((a[28] &gt;&gt; 2) &amp; 0x3f) | ((uint32_t)a[27] &lt;&lt; 6) | ((uint32_t)a[26] &lt;&lt; 14) | ((uint32_t)(a[25] &amp; 0xf) &lt;&lt; 22);
    r-&gt;n[2] = (uint32_t)((a[25] &gt;&gt; 4) &amp; 0xf) | ((uint32_t)a[24] &lt;&lt; 4) | ((uint32_t)a[23] &lt;&lt; 12) | ((uint32_t)(a[22] &amp; 0x3f) &lt;&lt; 20);
    r-&gt;n[3] = (uint32_t)((a[22] &gt;&gt; 6) &amp; 0x3) | ((uint32_t)a[21] &lt;&lt; 2) | ((uint32_t)a[20] &lt;&lt; 10) | ((uint32_t)a[19] &lt;&lt; 18);
    r-&gt;n[4] = (uint32_t)a[18] | ((uint32_t)a[17] &lt;&lt; 8) | ((uint32_t)a[16] &lt;&lt; 16) | ((uint32_t)(a[15] &amp; 0x3) &lt;&lt; 24);
    r-&gt;n[5] = (uint32_t)((a[15] &gt;&gt; 2) &amp; 0x3f) | ((uint32_t)a[14] &lt;&lt; 6) | ((uint32_t)a[13] &lt;&lt; 14) | ((uint32_t)(a[12] &amp; 0xf) &lt;&lt; 22);
    r-&gt;n[6] = (uint32_t)((a[12] &gt;&gt; 4) &amp; 0xf) | ((uint32_t)a[11] &lt;&lt; 4) | ((uint32_t)a[10] &lt;&lt; 12) | ((uint32_t)(a[9] &amp; 0x3f) &lt;&lt; 20);
    r-&gt;n[7] = (uint32_t)((a[9] &gt;&gt; 6) &amp; 0x3) | ((uint32_t)a[8] &lt;&lt; 2) | ((uint32_t)a[7] &lt;&lt; 10) | ((uint32_t)a[6] &lt;&lt; 18);
    r-&gt;n[8] = (uint32_t)a[5] | ((uint32_t)a[4] &lt;&lt; 8) | ((uint32_t)a[3] &lt;&lt; 16) | ((uint32_t)(a[2] &amp; 0x3) &lt;&lt; 24);
    r-&gt;n[9] = (uint32_t)((a[2] &gt;&gt; 2) &amp; 0x3f) | ((uint32_t)a[1] &lt;&lt; 6) | ((uint32_t)a[0] &lt;&lt; 14);

    if (r-&gt;n[9] == 0x3FFFFFUL &amp;&amp; (r-&gt;n[8] &amp; r-&gt;n[7] &amp; r-&gt;n[6] &amp; r-&gt;n[5] &amp; r-&gt;n[4] &amp; r-&gt;n[3] &amp; r-&gt;n[2]) == 0x3FFFFFFUL &amp;&amp; (r-&gt;n[1] + 0x40UL + ((r-&gt;n[0] + 0x3D1UL) &gt;&gt; 26)) &gt; 0x3FFFFFFUL) {
        return 0;
    }
#ifdef VERIFY
    r-&gt;magnitude = 1;
    r-&gt;normalized = 1;
    secp256k1_fe_verify(r);
#endif
    return 1;
}

/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */
static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {
#ifdef VERIFY
    VERIFY_CHECK(a-&gt;normalized);
    secp256k1_fe_verify(a);
#endif
    r[0] = (a-&gt;n[9] &gt;&gt; 14) &amp; 0xff;
    r[1] = (a-&gt;n[9] &gt;&gt; 6) &amp; 0xff;
    r[2] = ((a-&gt;n[9] &amp; 0x3F) &lt;&lt; 2) | ((a-&gt;n[8] &gt;&gt; 24) &amp; 0x3);
    r[3] = (a-&gt;n[8] &gt;&gt; 16) &amp; 0xff;
    r[4] = (a-&gt;n[8] &gt;&gt; 8) &amp; 0xff;
    r[5] = a-&gt;n[8] &amp; 0xff;
    r[6] = (a-&gt;n[7] &gt;&gt; 18) &amp; 0xff;
    r[7] = (a-&gt;n[7] &gt;&gt; 10) &amp; 0xff;
    r[8] = (a-&gt;n[7] &gt;&gt; 2) &amp; 0xff;
    r[9] = ((a-&gt;n[7] &amp; 0x3) &lt;&lt; 6) | ((a-&gt;n[6] &gt;&gt; 20) &amp; 0x3f);
    r[10] = (a-&gt;n[6] &gt;&gt; 12) &amp; 0xff;
    r[11] = (a-&gt;n[6] &gt;&gt; 4) &amp; 0xff;
    r[12] = ((a-&gt;n[6] &amp; 0xf) &lt;&lt; 4) | ((a-&gt;n[5] &gt;&gt; 22) &amp; 0xf);
    r[13] = (a-&gt;n[5] &gt;&gt; 14) &amp; 0xff;
    r[14] = (a-&gt;n[5] &gt;&gt; 6) &amp; 0xff;
    r[15] = ((a-&gt;n[5] &amp; 0x3f) &lt;&lt; 2) | ((a-&gt;n[4] &gt;&gt; 24) &amp; 0x3);
    r[16] = (a-&gt;n[4] &gt;&gt; 16) &amp; 0xff;
    r[17] = (a-&gt;n[4] &gt;&gt; 8) &amp; 0xff;
    r[18] = a-&gt;n[4] &amp; 0xff;
    r[19] = (a-&gt;n[3] &gt;&gt; 18) &amp; 0xff;
    r[20] = (a-&gt;n[3] &gt;&gt; 10) &amp; 0xff;
    r[21] = (a-&gt;n[3] &gt;&gt; 2) &amp; 0xff;
    r[22] = ((a-&gt;n[3] &amp; 0x3) &lt;&lt; 6) | ((a-&gt;n[2] &gt;&gt; 20) &amp; 0x3f);
    r[23] = (a-&gt;n[2] &gt;&gt; 12) &amp; 0xff;
    r[24] = (a-&gt;n[2] &gt;&gt; 4) &amp; 0xff;
    r[25] = ((a-&gt;n[2] &amp; 0xf) &lt;&lt; 4) | ((a-&gt;n[1] &gt;&gt; 22) &amp; 0xf);
    r[26] = (a-&gt;n[1] &gt;&gt; 14) &amp; 0xff;
    r[27] = (a-&gt;n[1] &gt;&gt; 6) &amp; 0xff;
    r[28] = ((a-&gt;n[1] &amp; 0x3f) &lt;&lt; 2) | ((a-&gt;n[0] &gt;&gt; 24) &amp; 0x3);
    r[29] = (a-&gt;n[0] &gt;&gt; 16) &amp; 0xff;
    r[30] = (a-&gt;n[0] &gt;&gt; 8) &amp; 0xff;
    r[31] = a-&gt;n[0] &amp; 0xff;
}

SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {
#ifdef VERIFY
    VERIFY_CHECK(a-&gt;magnitude &lt;= m);
    secp256k1_fe_verify(a);
#endif
    r-&gt;n[0] = 0x3FFFC2FUL * 2 * (m + 1) - a-&gt;n[0];
    r-&gt;n[1] = 0x3FFFFBFUL * 2 * (m + 1) - a-&gt;n[1];
    r-&gt;n[2] = 0x3FFFFFFUL * 2 * (m + 1) - a-&gt;n[2];
    r-&gt;n[3] = 0x3FFFFFFUL * 2 * (m + 1) - a-&gt;n[3];
    r-&gt;n[4] = 0x3FFFFFFUL * 2 * (m + 1) - a-&gt;n[4];
    r-&gt;n[5] = 0x3FFFFFFUL * 2 * (m + 1) - a-&gt;n[5];
    r-&gt;n[6] = 0x3FFFFFFUL * 2 * (m + 1) - a-&gt;n[6];
    r-&gt;n[7] = 0x3FFFFFFUL * 2 * (m + 1) - a-&gt;n[7];
    r-&gt;n[8] = 0x3FFFFFFUL * 2 * (m + 1) - a-&gt;n[8];
    r-&gt;n[9] = 0x03FFFFFUL * 2 * (m + 1) - a-&gt;n[9];
#ifdef VERIFY
    r-&gt;magnitude = m + 1;
    r-&gt;normalized = 0;
    secp256k1_fe_verify(r);
#endif
}

SECP256K1_INLINE static void secp256k1_fe_mul_int(secp256k1_fe *r, int a) {
    r-&gt;n[0] *= a;
    r-&gt;n[1] *= a;
    r-&gt;n[2] *= a;
    r-&gt;n[3] *= a;
    r-&gt;n[4] *= a;
    r-&gt;n[5] *= a;
    r-&gt;n[6] *= a;
    r-&gt;n[7] *= a;
    r-&gt;n[8] *= a;
    r-&gt;n[9] *= a;
#ifdef VERIFY
    r-&gt;magnitude *= a;
    r-&gt;normalized = 0;
    secp256k1_fe_verify(r);
#endif
}

SECP256K1_INLINE static void secp256k1_fe_add(secp256k1_fe *r, const secp256k1_fe *a) {
#ifdef VERIFY
    secp256k1_fe_verify(a);
#endif
    r-&gt;n[0] += a-&gt;n[0];
    r-&gt;n[1] += a-&gt;n[1];
    r-&gt;n[2] += a-&gt;n[2];
    r-&gt;n[3] += a-&gt;n[3];
    r-&gt;n[4] += a-&gt;n[4];
    r-&gt;n[5] += a-&gt;n[5];
    r-&gt;n[6] += a-&gt;n[6];
    r-&gt;n[7] += a-&gt;n[7];
    r-&gt;n[8] += a-&gt;n[8];
    r-&gt;n[9] += a-&gt;n[9];
#ifdef VERIFY
    r-&gt;magnitude += a-&gt;magnitude;
    r-&gt;normalized = 0;
    secp256k1_fe_verify(r);
#endif
}

#if defined(USE_EXTERNAL_ASM)

/* External assembler implementation */
void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b);
void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a);

#else

#ifdef VERIFY
#define VERIFY_BITS(x, n) VERIFY_CHECK(((x) &gt;&gt; (n)) == 0)
#else
#define VERIFY_BITS(x, n) do { } while(0)
#endif

SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b) {
<A NAME="1"></A>    uint64_t c, d;
    uint64_t u0, u1, u2, u3, u4, u5, u6, u7, u8;
    uint32_t t9, t1, t0, t2, t3, t4, t5, t6, t7;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match39-0.html#1',2,'match39-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    const uint32_t M = 0x3FFFFFFUL, R0 = 0x3D10UL, R1 = 0x400UL;

    VERIFY_BITS(a[0], 30);
    VERIFY_BITS(a[1], 30);
    VERIFY_BITS(a[2], 30);
    VERIFY_BITS(a[3], 30);
    VERIFY_BITS(a[4], 30);
    VERIFY_BITS(a[5], 30);
    VERIFY_BITS(a[6], 30);
    VERIFY_BITS(a[7], 30);
    VERIFY_BITS(a[8], 30);
    VERIFY_BITS(a[9], 26);
    VERIFY_BITS(b[0], 30);
    VERIFY_BITS(b[1], 30);
    VERIFY_BITS(b[2], 30);
    VERIFY_BITS(b[3], 30);
    VERIFY_BITS(b[4], 30);
    VERIFY_BITS(b[5], 30);
    VERIFY_BITS(b[6], 30);
    VERIFY_BITS(b[7], 30);
    VERIFY_BITS(b[8], 30);
    VERIFY_BITS(b[9], 26);

    /** [... a b c] is a shorthand for ... + a&lt;&lt;52 + b&lt;&lt;26 + c&lt;&lt;0 mod n.
     *  px is a shorthand for sum(a[i]*b[x-i], i=0..x).
     *  Note that [x 0 0 0 0 0 0 0 0 0 0] = [x*R1 x*R0].
     */

    d  = (uint64_t)a[0] * b[9]
       + (uint64_t)a[1] * b[8]
       + (uint64_t)a[2] * b[7]
       + (uint64_t)a[3] * b[6]
       + (uint64_t)a[4] * b[5]
       + (uint64_t)a[5] * b[4]
       + (uint64_t)a[6] * b[3]
       + (uint64_t)a[7] * b[2]
       + (uint64_t)a[8] * b[1]
       + (uint64_t)a[9] * b[0];
    /* VERIFY_BITS(d, 64); */
    /* [d 0 0 0 0 0 0 0 0 0] = [p9 0 0 0 0 0 0 0 0 0] */
    t9 = d &amp; M; d &gt;&gt;= 26;
    VERIFY_BITS(t9, 26);
    VERIFY_BITS(d, 38);
    /* [d t9 0 0 0 0 0 0 0 0 0] = [p9 0 0 0 0 0 0 0 0 0] */

    c  = (uint64_t)a[0] * b[0];
    VERIFY_BITS(c, 60);
    /* [d t9 0 0 0 0 0 0 0 0 c] = [p9 0 0 0 0 0 0 0 0 p0] */
    d += (uint64_t)a[1] * b[9]
       + (uint64_t)a[2] * b[8]
       + (uint64_t)a[3] * b[7]
       + (uint64_t)a[4] * b[6]
       + (uint64_t)a[5] * b[5]
       + (uint64_t)a[6] * b[4]
       + (uint64_t)a[7] * b[3]
       + (uint64_t)a[8] * b[2]
       + (uint64_t)a[9] * b[1];
    VERIFY_BITS(d, 63);
    /* [d t9 0 0 0 0 0 0 0 0 c] = [p10 p9 0 0 0 0 0 0 0 0 p0] */
    u0 = d &amp; M; d &gt;&gt;= 26; c += u0 * R0;
    VERIFY_BITS(u0, 26);
    VERIFY_BITS(d, 37);
    VERIFY_BITS(c, 61);
    /* [d u0 t9 0 0 0 0 0 0 0 0 c-u0*R0] = [p10 p9 0 0 0 0 0 0 0 0 p0] */
    t0 = c &amp; M; c &gt;&gt;= 26; c += u0 * R1;
    VERIFY_BITS(t0, 26);
    VERIFY_BITS(c, 37);
    /* [d u0 t9 0 0 0 0 0 0 0 c-u0*R1 t0-u0*R0] = [p10 p9 0 0 0 0 0 0 0 0 p0] */
    /* [d 0 t9 0 0 0 0 0 0 0 c t0] = [p10 p9 0 0 0 0 0 0 0 0 p0] */

    c += (uint64_t)a[0] * b[1]
       + (uint64_t)a[1] * b[0];
    VERIFY_BITS(c, 62);
    /* [d 0 t9 0 0 0 0 0 0 0 c t0] = [p10 p9 0 0 0 0 0 0 0 p1 p0] */
    d += (uint64_t)a[2] * b[9]
       + (uint64_t)a[3] * b[8]
       + (uint64_t)a[4] * b[7]
       + (uint64_t)a[5] * b[6]
       + (uint64_t)a[6] * b[5]
       + (uint64_t)a[7] * b[4]
       + (uint64_t)a[8] * b[3]
       + (uint64_t)a[9] * b[2];
    VERIFY_BITS(d, 63);
    /* [d 0 t9 0 0 0 0 0 0 0 c t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] */
    u1 = d &amp; M; d &gt;&gt;= 26; c += u1 * R0;
    VERIFY_BITS(u1, 26);
    VERIFY_BITS(d, 37);
    VERIFY_BITS(c, 63);
    /* [d u1 0 t9 0 0 0 0 0 0 0 c-u1*R0 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] */
    t1 = c &amp; M; c &gt;&gt;= 26; c += u1 * R1;
    VERIFY_BITS(t1, 26);
    VERIFY_BITS(c, 38);
    /* [d u1 0 t9 0 0 0 0 0 0 c-u1*R1 t1-u1*R0 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] */
    /* [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] */

    c += (uint64_t)a[0] * b[2]
       + (uint64_t)a[1] * b[1]
       + (uint64_t)a[2] * b[0];
    VERIFY_BITS(c, 62);
    /* [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */
    d += (uint64_t)a[3] * b[9]
       + (uint64_t)a[4] * b[8]
       + (uint64_t)a[5] * b[7]
       + (uint64_t)a[6] * b[6]
       + (uint64_t)a[7] * b[5]
       + (uint64_t)a[8] * b[4]
       + (uint64_t)a[9] * b[3];
    VERIFY_BITS(d, 63);
    /* [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */
    u2 = d &amp; M; d &gt;&gt;= 26; c += u2 * R0;
    VERIFY_BITS(u2, 26);
    VERIFY_BITS(d, 37);
    VERIFY_BITS(c, 63);
    /* [d u2 0 0 t9 0 0 0 0 0 0 c-u2*R0 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */
    t2 = c &amp; M; c &gt;&gt;= 26; c += u2 * R1;
    VERIFY_BITS(t2, 26);
    VERIFY_BITS(c, 38);
    /* [d u2 0 0 t9 0 0 0 0 0 c-u2*R1 t2-u2*R0 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */
    /* [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */

    c += (uint64_t)a[0] * b[3]
       + (uint64_t)a[1] * b[2]
       + (uint64_t)a[2] * b[1]
       + (uint64_t)a[3] * b[0];
    VERIFY_BITS(c, 63);
    /* [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */
    d += (uint64_t)a[4] * b[9]
       + (uint64_t)a[5] * b[8]
       + (uint64_t)a[6] * b[7]
       + (uint64_t)a[7] * b[6]
       + (uint64_t)a[8] * b[5]
       + (uint64_t)a[9] * b[4];
    VERIFY_BITS(d, 63);
    /* [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */
    u3 = d &amp; M; d &gt;&gt;= 26; c += u3 * R0;
    VERIFY_BITS(u3, 26);
    VERIFY_BITS(d, 37);
    /* VERIFY_BITS(c, 64); */
    /* [d u3 0 0 0 t9 0 0 0 0 0 c-u3*R0 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */
    t3 = c &amp; M; c &gt;&gt;= 26; c += u3 * R1;
    VERIFY_BITS(t3, 26);
    VERIFY_BITS(c, 39);
    /* [d u3 0 0 0 t9 0 0 0 0 c-u3*R1 t3-u3*R0 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */
    /* [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */

    c += (uint64_t)a[0] * b[4]
       + (uint64_t)a[1] * b[3]
       + (uint64_t)a[2] * b[2]
       + (uint64_t)a[3] * b[1]
       + (uint64_t)a[4] * b[0];
    VERIFY_BITS(c, 63);
    /* [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */
    d += (uint64_t)a[5] * b[9]
       + (uint64_t)a[6] * b[8]
       + (uint64_t)a[7] * b[7]
       + (uint64_t)a[8] * b[6]
       + (uint64_t)a[9] * b[5];
    VERIFY_BITS(d, 62);
    /* [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */
    u4 = d &amp; M; d &gt;&gt;= 26; c += u4 * R0;</B></FONT>
    VERIFY_BITS(u4, 26);
    VERIFY_BITS(d, 36);
    /* VERIFY_BITS(c, 64); */
    /* [d u4 0 0 0 0 t9 0 0 0 0 c-u4*R0 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */
    t4 = c &amp; M; c &gt;&gt;= 26; c += u4 * R1;
    VERIFY_BITS(t4, 26);
    VERIFY_BITS(c, 39);
    /* [d u4 0 0 0 0 t9 0 0 0 c-u4*R1 t4-u4*R0 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */

    c += (uint64_t)a[0] * b[5]
       + (uint64_t)a[1] * b[4]
       + (uint64_t)a[2] * b[3]
       + (uint64_t)a[3] * b[2]
       + (uint64_t)a[4] * b[1]
       + (uint64_t)a[5] * b[0];
    VERIFY_BITS(c, 63);
    /* [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */
    d += (uint64_t)a[6] * b[9]
       + (uint64_t)a[7] * b[8]
       + (uint64_t)a[8] * b[7]
       + (uint64_t)a[9] * b[6];
    VERIFY_BITS(d, 62);
    /* [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */
    u5 = d &amp; M; d &gt;&gt;= 26; c += u5 * R0;
    VERIFY_BITS(u5, 26);
    VERIFY_BITS(d, 36);
    /* VERIFY_BITS(c, 64); */
    /* [d u5 0 0 0 0 0 t9 0 0 0 c-u5*R0 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */
    t5 = c &amp; M; c &gt;&gt;= 26; c += u5 * R1;
    VERIFY_BITS(t5, 26);
    VERIFY_BITS(c, 39);
    /* [d u5 0 0 0 0 0 t9 0 0 c-u5*R1 t5-u5*R0 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */

    c += (uint64_t)a[0] * b[6]
       + (uint64_t)a[1] * b[5]
       + (uint64_t)a[2] * b[4]
       + (uint64_t)a[3] * b[3]
       + (uint64_t)a[4] * b[2]
       + (uint64_t)a[5] * b[1]
       + (uint64_t)a[6] * b[0];
    VERIFY_BITS(c, 63);
    /* [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */
    d += (uint64_t)a[7] * b[9]
       + (uint64_t)a[8] * b[8]
<A NAME="0"></A>       + (uint64_t)a[9] * b[7];
    VERIFY_BITS(d, 61);
    /* [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match39-0.html#0',2,'match39-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    u6 = d &amp; M; d &gt;&gt;= 26; c += u6 * R0;
    VERIFY_BITS(u6, 26);
    VERIFY_BITS(d, 35);
    /* VERIFY_BITS(c, 64); */
    /* [d u6 0 0 0 0 0 0 t9 0 0 c-u6*R0 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */
    t6 = c &amp; M; c &gt;&gt;= 26; c += u6 * R1;
    VERIFY_BITS(t6, 26);
    VERIFY_BITS(c, 39);
    /* [d u6 0 0 0 0 0 0 t9 0 c-u6*R1 t6-u6*R0 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */

    c += (uint64_t)a[0] * b[7]
       + (uint64_t)a[1] * b[6]
       + (uint64_t)a[2] * b[5]
       + (uint64_t)a[3] * b[4]
       + (uint64_t)a[4] * b[3]
       + (uint64_t)a[5] * b[2]
       + (uint64_t)a[6] * b[1]
       + (uint64_t)a[7] * b[0];
    /* VERIFY_BITS(c, 64); */
    VERIFY_CHECK(c &lt;= 0x8000007C00000007ULL);
    /* [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */
    d += (uint64_t)a[8] * b[9]
       + (uint64_t)a[9] * b[8];
    VERIFY_BITS(d, 58);
    /* [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */
    u7 = d &amp; M; d &gt;&gt;= 26; c += u7 * R0;
    VERIFY_BITS(u7, 26);
    VERIFY_BITS(d, 32);
    /* VERIFY_BITS(c, 64); */
    VERIFY_CHECK(c &lt;= 0x800001703FFFC2F7ULL);
    /* [d u7 0 0 0 0 0 0 0 t9 0 c-u7*R0 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */
    t7 = c &amp; M; c &gt;&gt;= 26; c += u7 * R1;
    VERIFY_BITS(t7, 26);
    VERIFY_BITS(c, 38);
    /* [d u7 0 0 0 0 0 0 0 t9 c-u7*R1 t7-u7*R0 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */

    c += (uint64_t)a[0] * b[8]
       + (uint64_t)a[1] * b[7]
       + (uint64_t)a[2] * b[6]
       + (uint64_t)a[3] * b[5]
       + (uint64_t)a[4] * b[4]
       + (uint64_t)a[5] * b[3]
       + (uint64_t)a[6] * b[2]
       + (uint64_t)a[7] * b[1]
       + (uint64_t)a[8] * b[0];
    /* VERIFY_BITS(c, 64); */
    VERIFY_CHECK(c &lt;= 0x9000007B80000008ULL);
    /* [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    d += (uint64_t)a[9] * b[9];
    VERIFY_BITS(d, 57);
    /* [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    u8 = d &amp; M; d &gt;&gt;= 26; c += u8 * R0;
    VERIFY_BITS(u8, 26);
    VERIFY_BITS(d, 31);
    /* VERIFY_BITS(c, 64); */
    VERIFY_CHECK(c &lt;= 0x9000016FBFFFC2F8ULL);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 t4 t3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */

    r[3] = t3;
    VERIFY_BITS(r[3], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 t4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[4] = t4;
    VERIFY_BITS(r[4], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[5] = t5;
    VERIFY_BITS(r[5], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[6] = t6;
    VERIFY_BITS(r[6], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[7] = t7;
    VERIFY_BITS(r[7], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */

    r[8] = c &amp; M; c &gt;&gt;= 26; c += u8 * R1;
    VERIFY_BITS(r[8], 26);
    VERIFY_BITS(c, 39);
    /* [d u8 0 0 0 0 0 0 0 0 t9+c-u8*R1 r8-u8*R0 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 0 0 0 t9+c r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    c   += d * R0 + t9;
    VERIFY_BITS(c, 45);
    /* [d 0 0 0 0 0 0 0 0 0 c-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[9] = c &amp; (M &gt;&gt; 4); c &gt;&gt;= 22; c += d * (R1 &lt;&lt; 4);
    VERIFY_BITS(r[9], 22);
    VERIFY_BITS(c, 46);
    /* [d 0 0 0 0 0 0 0 0 r9+((c-d*R1&lt;&lt;4)&lt;&lt;22)-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 0 -d*R1 r9+(c&lt;&lt;22)-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */

    d    = c * (R0 &gt;&gt; 4) + t0;
    VERIFY_BITS(d, 56);
    /* [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1 d-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[0] = d &amp; M; d &gt;&gt;= 26;
    VERIFY_BITS(r[0], 26);
    VERIFY_BITS(d, 30);
    /* [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1+d r0-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    d   += c * (R1 &gt;&gt; 4) + t1;
    VERIFY_BITS(d, 53);
    VERIFY_CHECK(d &lt;= 0x10000003FFFFBFULL);
    /* [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 d-c*R1&gt;&gt;4 r0-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [r9 r8 r7 r6 r5 r4 r3 t2 d r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[1] = d &amp; M; d &gt;&gt;= 26;
    VERIFY_BITS(r[1], 26);
    VERIFY_BITS(d, 27);
    VERIFY_CHECK(d &lt;= 0x4000000ULL);
    /* [r9 r8 r7 r6 r5 r4 r3 t2+d r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    d   += t2;
    VERIFY_BITS(d, 27);
    /* [r9 r8 r7 r6 r5 r4 r3 d r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[2] = d;
    VERIFY_BITS(r[2], 27);
    /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
}

SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a) {</B></FONT>
    uint64_t c, d;
    uint64_t u0, u1, u2, u3, u4, u5, u6, u7, u8;
    uint32_t t9, t0, t1, t2, t3, t4, t5, t6, t7;
    const uint32_t M = 0x3FFFFFFUL, R0 = 0x3D10UL, R1 = 0x400UL;

    VERIFY_BITS(a[0], 30);
    VERIFY_BITS(a[1], 30);
    VERIFY_BITS(a[2], 30);
    VERIFY_BITS(a[3], 30);
    VERIFY_BITS(a[4], 30);
    VERIFY_BITS(a[5], 30);
    VERIFY_BITS(a[6], 30);
    VERIFY_BITS(a[7], 30);
    VERIFY_BITS(a[8], 30);
    VERIFY_BITS(a[9], 26);

    /** [... a b c] is a shorthand for ... + a&lt;&lt;52 + b&lt;&lt;26 + c&lt;&lt;0 mod n.
     *  px is a shorthand for sum(a[i]*a[x-i], i=0..x).
     *  Note that [x 0 0 0 0 0 0 0 0 0 0] = [x*R1 x*R0].
     */

    d  = (uint64_t)(a[0]*2) * a[9]
       + (uint64_t)(a[1]*2) * a[8]
       + (uint64_t)(a[2]*2) * a[7]
       + (uint64_t)(a[3]*2) * a[6]
       + (uint64_t)(a[4]*2) * a[5];
    /* VERIFY_BITS(d, 64); */
    /* [d 0 0 0 0 0 0 0 0 0] = [p9 0 0 0 0 0 0 0 0 0] */
    t9 = d &amp; M; d &gt;&gt;= 26;
    VERIFY_BITS(t9, 26);
    VERIFY_BITS(d, 38);
    /* [d t9 0 0 0 0 0 0 0 0 0] = [p9 0 0 0 0 0 0 0 0 0] */

    c  = (uint64_t)a[0] * a[0];
    VERIFY_BITS(c, 60);
    /* [d t9 0 0 0 0 0 0 0 0 c] = [p9 0 0 0 0 0 0 0 0 p0] */
    d += (uint64_t)(a[1]*2) * a[9]
       + (uint64_t)(a[2]*2) * a[8]
       + (uint64_t)(a[3]*2) * a[7]
       + (uint64_t)(a[4]*2) * a[6]
       + (uint64_t)a[5] * a[5];
    VERIFY_BITS(d, 63);
    /* [d t9 0 0 0 0 0 0 0 0 c] = [p10 p9 0 0 0 0 0 0 0 0 p0] */
    u0 = d &amp; M; d &gt;&gt;= 26; c += u0 * R0;
    VERIFY_BITS(u0, 26);
    VERIFY_BITS(d, 37);
    VERIFY_BITS(c, 61);
    /* [d u0 t9 0 0 0 0 0 0 0 0 c-u0*R0] = [p10 p9 0 0 0 0 0 0 0 0 p0] */
    t0 = c &amp; M; c &gt;&gt;= 26; c += u0 * R1;
    VERIFY_BITS(t0, 26);
    VERIFY_BITS(c, 37);
    /* [d u0 t9 0 0 0 0 0 0 0 c-u0*R1 t0-u0*R0] = [p10 p9 0 0 0 0 0 0 0 0 p0] */
    /* [d 0 t9 0 0 0 0 0 0 0 c t0] = [p10 p9 0 0 0 0 0 0 0 0 p0] */

    c += (uint64_t)(a[0]*2) * a[1];
    VERIFY_BITS(c, 62);
    /* [d 0 t9 0 0 0 0 0 0 0 c t0] = [p10 p9 0 0 0 0 0 0 0 p1 p0] */
    d += (uint64_t)(a[2]*2) * a[9]
       + (uint64_t)(a[3]*2) * a[8]
       + (uint64_t)(a[4]*2) * a[7]
       + (uint64_t)(a[5]*2) * a[6];
    VERIFY_BITS(d, 63);
    /* [d 0 t9 0 0 0 0 0 0 0 c t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] */
    u1 = d &amp; M; d &gt;&gt;= 26; c += u1 * R0;
    VERIFY_BITS(u1, 26);
    VERIFY_BITS(d, 37);
    VERIFY_BITS(c, 63);
    /* [d u1 0 t9 0 0 0 0 0 0 0 c-u1*R0 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] */
    t1 = c &amp; M; c &gt;&gt;= 26; c += u1 * R1;
    VERIFY_BITS(t1, 26);
    VERIFY_BITS(c, 38);
    /* [d u1 0 t9 0 0 0 0 0 0 c-u1*R1 t1-u1*R0 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] */
    /* [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] */

    c += (uint64_t)(a[0]*2) * a[2]
       + (uint64_t)a[1] * a[1];
    VERIFY_BITS(c, 62);
    /* [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */
    d += (uint64_t)(a[3]*2) * a[9]
       + (uint64_t)(a[4]*2) * a[8]
       + (uint64_t)(a[5]*2) * a[7]
       + (uint64_t)a[6] * a[6];
    VERIFY_BITS(d, 63);
    /* [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */
    u2 = d &amp; M; d &gt;&gt;= 26; c += u2 * R0;
    VERIFY_BITS(u2, 26);
    VERIFY_BITS(d, 37);
    VERIFY_BITS(c, 63);
    /* [d u2 0 0 t9 0 0 0 0 0 0 c-u2*R0 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */
    t2 = c &amp; M; c &gt;&gt;= 26; c += u2 * R1;
    VERIFY_BITS(t2, 26);
    VERIFY_BITS(c, 38);
    /* [d u2 0 0 t9 0 0 0 0 0 c-u2*R1 t2-u2*R0 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */
    /* [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] */

    c += (uint64_t)(a[0]*2) * a[3]
       + (uint64_t)(a[1]*2) * a[2];
    VERIFY_BITS(c, 63);
    /* [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */
    d += (uint64_t)(a[4]*2) * a[9]
       + (uint64_t)(a[5]*2) * a[8]
       + (uint64_t)(a[6]*2) * a[7];
    VERIFY_BITS(d, 63);
    /* [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */
    u3 = d &amp; M; d &gt;&gt;= 26; c += u3 * R0;
    VERIFY_BITS(u3, 26);
    VERIFY_BITS(d, 37);
    /* VERIFY_BITS(c, 64); */
    /* [d u3 0 0 0 t9 0 0 0 0 0 c-u3*R0 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */
    t3 = c &amp; M; c &gt;&gt;= 26; c += u3 * R1;
    VERIFY_BITS(t3, 26);
    VERIFY_BITS(c, 39);
    /* [d u3 0 0 0 t9 0 0 0 0 c-u3*R1 t3-u3*R0 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */
    /* [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] */

    c += (uint64_t)(a[0]*2) * a[4]
       + (uint64_t)(a[1]*2) * a[3]
       + (uint64_t)a[2] * a[2];
    VERIFY_BITS(c, 63);
    /* [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */
    d += (uint64_t)(a[5]*2) * a[9]
       + (uint64_t)(a[6]*2) * a[8]
       + (uint64_t)a[7] * a[7];
    VERIFY_BITS(d, 62);
    /* [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */
    u4 = d &amp; M; d &gt;&gt;= 26; c += u4 * R0;
    VERIFY_BITS(u4, 26);
    VERIFY_BITS(d, 36);
    /* VERIFY_BITS(c, 64); */
    /* [d u4 0 0 0 0 t9 0 0 0 0 c-u4*R0 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */
    t4 = c &amp; M; c &gt;&gt;= 26; c += u4 * R1;
    VERIFY_BITS(t4, 26);
    VERIFY_BITS(c, 39);
    /* [d u4 0 0 0 0 t9 0 0 0 c-u4*R1 t4-u4*R0 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] */

    c += (uint64_t)(a[0]*2) * a[5]
       + (uint64_t)(a[1]*2) * a[4]
       + (uint64_t)(a[2]*2) * a[3];
    VERIFY_BITS(c, 63);
    /* [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */
    d += (uint64_t)(a[6]*2) * a[9]
       + (uint64_t)(a[7]*2) * a[8];
    VERIFY_BITS(d, 62);
    /* [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */
    u5 = d &amp; M; d &gt;&gt;= 26; c += u5 * R0;
    VERIFY_BITS(u5, 26);
    VERIFY_BITS(d, 36);
    /* VERIFY_BITS(c, 64); */
    /* [d u5 0 0 0 0 0 t9 0 0 0 c-u5*R0 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */
    t5 = c &amp; M; c &gt;&gt;= 26; c += u5 * R1;
    VERIFY_BITS(t5, 26);
    VERIFY_BITS(c, 39);
    /* [d u5 0 0 0 0 0 t9 0 0 c-u5*R1 t5-u5*R0 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] */

    c += (uint64_t)(a[0]*2) * a[6]
       + (uint64_t)(a[1]*2) * a[5]
       + (uint64_t)(a[2]*2) * a[4]
       + (uint64_t)a[3] * a[3];
    VERIFY_BITS(c, 63);
    /* [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */
    d += (uint64_t)(a[7]*2) * a[9]
       + (uint64_t)a[8] * a[8];
    VERIFY_BITS(d, 61);
    /* [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */
    u6 = d &amp; M; d &gt;&gt;= 26; c += u6 * R0;
    VERIFY_BITS(u6, 26);
    VERIFY_BITS(d, 35);
    /* VERIFY_BITS(c, 64); */
    /* [d u6 0 0 0 0 0 0 t9 0 0 c-u6*R0 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */
    t6 = c &amp; M; c &gt;&gt;= 26; c += u6 * R1;
    VERIFY_BITS(t6, 26);
    VERIFY_BITS(c, 39);
    /* [d u6 0 0 0 0 0 0 t9 0 c-u6*R1 t6-u6*R0 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] */

    c += (uint64_t)(a[0]*2) * a[7]
       + (uint64_t)(a[1]*2) * a[6]
       + (uint64_t)(a[2]*2) * a[5]
       + (uint64_t)(a[3]*2) * a[4];
    /* VERIFY_BITS(c, 64); */
    VERIFY_CHECK(c &lt;= 0x8000007C00000007ULL);
    /* [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */
    d += (uint64_t)(a[8]*2) * a[9];
    VERIFY_BITS(d, 58);
    /* [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */
    u7 = d &amp; M; d &gt;&gt;= 26; c += u7 * R0;
    VERIFY_BITS(u7, 26);
    VERIFY_BITS(d, 32);
    /* VERIFY_BITS(c, 64); */
    VERIFY_CHECK(c &lt;= 0x800001703FFFC2F7ULL);
    /* [d u7 0 0 0 0 0 0 0 t9 0 c-u7*R0 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */
    t7 = c &amp; M; c &gt;&gt;= 26; c += u7 * R1;
    VERIFY_BITS(t7, 26);
    VERIFY_BITS(c, 38);
    /* [d u7 0 0 0 0 0 0 0 t9 c-u7*R1 t7-u7*R0 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] */

    c += (uint64_t)(a[0]*2) * a[8]
       + (uint64_t)(a[1]*2) * a[7]
       + (uint64_t)(a[2]*2) * a[6]
       + (uint64_t)(a[3]*2) * a[5]
       + (uint64_t)a[4] * a[4];
    /* VERIFY_BITS(c, 64); */
    VERIFY_CHECK(c &lt;= 0x9000007B80000008ULL);
    /* [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    d += (uint64_t)a[9] * a[9];
    VERIFY_BITS(d, 57);
    /* [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    u8 = d &amp; M; d &gt;&gt;= 26; c += u8 * R0;
    VERIFY_BITS(u8, 26);
    VERIFY_BITS(d, 31);
    /* VERIFY_BITS(c, 64); */
    VERIFY_CHECK(c &lt;= 0x9000016FBFFFC2F8ULL);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 t4 t3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */

    r[3] = t3;
    VERIFY_BITS(r[3], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 t4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[4] = t4;
    VERIFY_BITS(r[4], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[5] = t5;
    VERIFY_BITS(r[5], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[6] = t6;
    VERIFY_BITS(r[6], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[7] = t7;
    VERIFY_BITS(r[7], 26);
    /* [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */

    r[8] = c &amp; M; c &gt;&gt;= 26; c += u8 * R1;
    VERIFY_BITS(r[8], 26);
    VERIFY_BITS(c, 39);
    /* [d u8 0 0 0 0 0 0 0 0 t9+c-u8*R1 r8-u8*R0 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 0 0 0 t9+c r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    c   += d * R0 + t9;
    VERIFY_BITS(c, 45);
    /* [d 0 0 0 0 0 0 0 0 0 c-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[9] = c &amp; (M &gt;&gt; 4); c &gt;&gt;= 22; c += d * (R1 &lt;&lt; 4);
    VERIFY_BITS(r[9], 22);
    VERIFY_BITS(c, 46);
    /* [d 0 0 0 0 0 0 0 0 r9+((c-d*R1&lt;&lt;4)&lt;&lt;22)-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [d 0 0 0 0 0 0 0 -d*R1 r9+(c&lt;&lt;22)-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */

    d    = c * (R0 &gt;&gt; 4) + t0;
    VERIFY_BITS(d, 56);
    /* [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1 d-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[0] = d &amp; M; d &gt;&gt;= 26;
    VERIFY_BITS(r[0], 26);
    VERIFY_BITS(d, 30);
    /* [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1+d r0-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    d   += c * (R1 &gt;&gt; 4) + t1;
    VERIFY_BITS(d, 53);
    VERIFY_CHECK(d &lt;= 0x10000003FFFFBFULL);
    /* [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 d-c*R1&gt;&gt;4 r0-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    /* [r9 r8 r7 r6 r5 r4 r3 t2 d r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[1] = d &amp; M; d &gt;&gt;= 26;
    VERIFY_BITS(r[1], 26);
    VERIFY_BITS(d, 27);
    VERIFY_CHECK(d &lt;= 0x4000000ULL);
    /* [r9 r8 r7 r6 r5 r4 r3 t2+d r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    d   += t2;
    VERIFY_BITS(d, 27);
    /* [r9 r8 r7 r6 r5 r4 r3 d r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
    r[2] = d;
    VERIFY_BITS(r[2], 27);
    /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */
}
#endif

static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp256k1_fe * SECP256K1_RESTRICT b) {
#ifdef VERIFY
    VERIFY_CHECK(a-&gt;magnitude &lt;= 8);
    VERIFY_CHECK(b-&gt;magnitude &lt;= 8);
    secp256k1_fe_verify(a);
    secp256k1_fe_verify(b);
    VERIFY_CHECK(r != b);
#endif
    secp256k1_fe_mul_inner(r-&gt;n, a-&gt;n, b-&gt;n);
#ifdef VERIFY
    r-&gt;magnitude = 1;
    r-&gt;normalized = 0;
    secp256k1_fe_verify(r);
#endif
}

static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a) {
#ifdef VERIFY
    VERIFY_CHECK(a-&gt;magnitude &lt;= 8);
    secp256k1_fe_verify(a);
#endif
    secp256k1_fe_sqr_inner(r-&gt;n, a-&gt;n);
#ifdef VERIFY
    r-&gt;magnitude = 1;
    r-&gt;normalized = 0;
    secp256k1_fe_verify(r);
#endif
}

static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag) {
    uint32_t mask0, mask1;
    mask0 = flag + ~((uint32_t)0);
    mask1 = ~mask0;
    r-&gt;n[0] = (r-&gt;n[0] &amp; mask0) | (a-&gt;n[0] &amp; mask1);
    r-&gt;n[1] = (r-&gt;n[1] &amp; mask0) | (a-&gt;n[1] &amp; mask1);
    r-&gt;n[2] = (r-&gt;n[2] &amp; mask0) | (a-&gt;n[2] &amp; mask1);
    r-&gt;n[3] = (r-&gt;n[3] &amp; mask0) | (a-&gt;n[3] &amp; mask1);
    r-&gt;n[4] = (r-&gt;n[4] &amp; mask0) | (a-&gt;n[4] &amp; mask1);
    r-&gt;n[5] = (r-&gt;n[5] &amp; mask0) | (a-&gt;n[5] &amp; mask1);
    r-&gt;n[6] = (r-&gt;n[6] &amp; mask0) | (a-&gt;n[6] &amp; mask1);
    r-&gt;n[7] = (r-&gt;n[7] &amp; mask0) | (a-&gt;n[7] &amp; mask1);
    r-&gt;n[8] = (r-&gt;n[8] &amp; mask0) | (a-&gt;n[8] &amp; mask1);
    r-&gt;n[9] = (r-&gt;n[9] &amp; mask0) | (a-&gt;n[9] &amp; mask1);
#ifdef VERIFY
    if (a-&gt;magnitude &gt; r-&gt;magnitude) {
        r-&gt;magnitude = a-&gt;magnitude;
    }
    r-&gt;normalized &amp;= a-&gt;normalized;
#endif
}

static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_fe_storage *a, int flag) {
    uint32_t mask0, mask1;
    mask0 = flag + ~((uint32_t)0);
    mask1 = ~mask0;
    r-&gt;n[0] = (r-&gt;n[0] &amp; mask0) | (a-&gt;n[0] &amp; mask1);
    r-&gt;n[1] = (r-&gt;n[1] &amp; mask0) | (a-&gt;n[1] &amp; mask1);
    r-&gt;n[2] = (r-&gt;n[2] &amp; mask0) | (a-&gt;n[2] &amp; mask1);
    r-&gt;n[3] = (r-&gt;n[3] &amp; mask0) | (a-&gt;n[3] &amp; mask1);
    r-&gt;n[4] = (r-&gt;n[4] &amp; mask0) | (a-&gt;n[4] &amp; mask1);
    r-&gt;n[5] = (r-&gt;n[5] &amp; mask0) | (a-&gt;n[5] &amp; mask1);
    r-&gt;n[6] = (r-&gt;n[6] &amp; mask0) | (a-&gt;n[6] &amp; mask1);
    r-&gt;n[7] = (r-&gt;n[7] &amp; mask0) | (a-&gt;n[7] &amp; mask1);
}

static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe *a) {
#ifdef VERIFY
    VERIFY_CHECK(a-&gt;normalized);
#endif
    r-&gt;n[0] = a-&gt;n[0] | a-&gt;n[1] &lt;&lt; 26;
    r-&gt;n[1] = a-&gt;n[1] &gt;&gt; 6 | a-&gt;n[2] &lt;&lt; 20;
    r-&gt;n[2] = a-&gt;n[2] &gt;&gt; 12 | a-&gt;n[3] &lt;&lt; 14;
    r-&gt;n[3] = a-&gt;n[3] &gt;&gt; 18 | a-&gt;n[4] &lt;&lt; 8;
    r-&gt;n[4] = a-&gt;n[4] &gt;&gt; 24 | a-&gt;n[5] &lt;&lt; 2 | a-&gt;n[6] &lt;&lt; 28;
    r-&gt;n[5] = a-&gt;n[6] &gt;&gt; 4 | a-&gt;n[7] &lt;&lt; 22;
    r-&gt;n[6] = a-&gt;n[7] &gt;&gt; 10 | a-&gt;n[8] &lt;&lt; 16;
    r-&gt;n[7] = a-&gt;n[8] &gt;&gt; 16 | a-&gt;n[9] &lt;&lt; 10;
}

static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const secp256k1_fe_storage *a) {
    r-&gt;n[0] = a-&gt;n[0] &amp; 0x3FFFFFFUL;
    r-&gt;n[1] = a-&gt;n[0] &gt;&gt; 26 | ((a-&gt;n[1] &lt;&lt; 6) &amp; 0x3FFFFFFUL);
    r-&gt;n[2] = a-&gt;n[1] &gt;&gt; 20 | ((a-&gt;n[2] &lt;&lt; 12) &amp; 0x3FFFFFFUL);
    r-&gt;n[3] = a-&gt;n[2] &gt;&gt; 14 | ((a-&gt;n[3] &lt;&lt; 18) &amp; 0x3FFFFFFUL);
    r-&gt;n[4] = a-&gt;n[3] &gt;&gt; 8 | ((a-&gt;n[4] &lt;&lt; 24) &amp; 0x3FFFFFFUL);
    r-&gt;n[5] = (a-&gt;n[4] &gt;&gt; 2) &amp; 0x3FFFFFFUL;
    r-&gt;n[6] = a-&gt;n[4] &gt;&gt; 28 | ((a-&gt;n[5] &lt;&lt; 4) &amp; 0x3FFFFFFUL);
    r-&gt;n[7] = a-&gt;n[5] &gt;&gt; 22 | ((a-&gt;n[6] &lt;&lt; 10) &amp; 0x3FFFFFFUL);
    r-&gt;n[8] = a-&gt;n[6] &gt;&gt; 16 | ((a-&gt;n[7] &lt;&lt; 16) &amp; 0x3FFFFFFUL);
    r-&gt;n[9] = a-&gt;n[7] &gt;&gt; 10;
#ifdef VERIFY
    r-&gt;magnitude = 1;
    r-&gt;normalized = 1;
#endif
}

#endif /* SECP256K1_FIELD_REPR_IMPL_H */
</PRE>
</BODY>
</HTML>
